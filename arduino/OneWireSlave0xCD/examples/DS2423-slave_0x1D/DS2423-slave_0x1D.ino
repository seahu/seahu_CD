/*
   Simulation of DS2423 (1-Wire Temperature sensor)
   -------------------------------------------------

   Copyright (C) 2020 Ondrej Lycka info (at) seahu.cz

   The skeleton requres an incllude file with the device-specific dependent command handling.
   
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.

   Simulation of DS2423 (1-Wire 4Kbit RAM with Counter)
   ----------------------------------------------------
   
   Example is for AVR_ATtiny85 can be also used on arduino uno, nano and leonardo, micro
   (default One Wire pin for other platform refer to suportedMCU.h).
   Hardware platform and some options must be set into header (platform.h) file.
   Device ID is generated by base on compile date and time
   Counter use internal analog comparator to detect poweroff for save counter data on EEPROM (EEPROM have only ~100 000 revretes).
   OneWire famyly code: 0x1D
   Note:
   The 4Kb (512B) DS2423 memory is organized into 16 pages, each with 32B. Each page has its own "32b counter", but the first 12 connectors are not really counters, they have a statically set maximum value of 4294967295,
   Counters 13 and 14 are incremented by writing data to their memory page (write counters).
   13 counter in this implementation is also incremented during shutdown (can be used as a shutdown counter). During shutdown, data from RAM is stored in the EEPROM. Only approximately 100,000 rewrite cycles (power off) are guaranteed.
   14 and 15 counters are counters connected to real pins (counterA, counterB)
   
   !! Because AVR_ATtiny85 has little RAM, the memory is reduced to 64B => 2 pages x 32B in this implementation. The data from these two pages is mirrored on the other 14 pages.
   !! Less memory is an issue if you plan to use this device as memory, but don't mind using it as a counter

   Tested:
   on arduino nano and:
   Linux kerned river OK
   owfs.org - reading counters and memory OK. But not function  write into memory (it look as mistake of OWFS)
   
   
                                                                                                / \ +5V
                                                                                                 |
                                                                                 +---------------+
                                                                                 |               |
                                                                                +-+  BAT         |
                                                                                \ /  41         +-+ BAT
                                                                                ---             \ / 41
                                                           +------+--------------|              ---
                                                           |      | 100nF        | 450uF         |
                                                           |    -----          -----             |
                                    AVR_ATtiny85           |    -----          -----             |
                                   +------\/-----+         |      |              |              +-+
                    (RESET) N/U 1 -|1 PB5   VCC 8|- 8 VCC--+     ---            ---             | |20K
      CounterA <-------- A3  D3 2 -|2 PB3   PB2 7|- 7 D2 A1 (SLC,INT0) ----> 1-Wire             +-+
      CounterB <- (OC1B) A2 #D4 3 -|3 PB4   PB1 6|- 6 #D1   (MISO,OC0B,AIN1,OC1A)----------------|
                         GND D5 4 -|4 GND   PB0 5|- 5 #D0   (MOSI,OC0A,AIN0,SDA,AREF)--+        +-+
                                   +-------------+                                     |        | |47K
                                                                                  CounterC      +-+
                                                                                                 |
                                                                                                ---
*/


#include "platform.h"
#include <OneWireSlave.h>
#include <avr/pgmspace.h>
#include <EEPROM.h>
#include <string.h>
#include "eeprom_lib.h"
#include "comptime.h"

#define FAM 0x1D // family ROM code
#define EE_FIRST_RUN 0 // EEPROM address for check frist run (frist run write default values into EEPROM and save 0xAA on this address)
#define EE_START_POINT 20 // define start point to load and save data to EEPROM

#define COUNTER_A           4 // pin of conter A
#define COUNTER_B           5 // pin of conter B


#define MEM_SIZE            64
#define PAGE_SIZE           32
#define PAGE_MASK           0b00011111
#define MEMORY_MASK_HUCK    0b00111111 // oreginal MEM_SIZE is 512B, this is so much for AVR_ATtiny85, this is huck to degrease memory to 64B
#define COUNTER_COUNT       4          // only for page 13 to 15
#define COUNTER_PAGE_START  12
#define REG_ES_PF_MASK      0b00100000 // partial byte flag
#define REG_ES_ZERO_MASK    0b01000000 // reads always zero
#define REG_ES_AA_MASK      0b10000000 // authorization accepted (data copied to target memory)
#define REG_TA_MASK         0x01FF     // Adresses will be stripped of the highest 7 bytes
#define DUMMY_32b_ZERO      0x00000000 // should be std::numeric_limits<uint32_t>::lowest()
#define DUMMY_32b_ONES      0xFFFFFFFF
#define ALTERNATING_10      0xAA

// global variables
uint8_t     memory[MEM_SIZE]; // 4kbit max storage
uint8_t     scratchpad[PAGE_SIZE];
uint32_t    memcounter[COUNTER_COUNT+1]; // start from page 13 to page 15, and one more is for DUMMY_32b_ZERO or DUMMY_32b_ONES
uint16_t    reg_TA;
uint8_t     reg_ES;
uint8_t     data;
uint16_t    crc;
bool        last_counterA;
bool        last_counterB;


// GENERATION OF UNIQUE ROM CODE
uint8_t rom__[8] = { FAM, SERIAL_NUMBER, 0x00 }; // SERIAL_NUMBER will be generated by timestamp during compile proces
//   will be calculated in begin:-------^^^^


OneWireSlave ow;  // global variable to class OneWireSlave


//-------------- AUXILIARY FUNCTIONS -----------------------------------------

bool writeMemory(const uint8_t* const source, const uint16_t length, const uint16_t position){
    if (position >= MEM_SIZE) return false;
    // withou hack to reduce data RAM
    //const uint16_t _length = (position + length >= MEM_SIZE) ? (MEM_SIZE - position) : length;
    //memcpy(&memory[position],source,_length);

    // some as higer, bat check lenght and copy to nemory with hack to reduce data RAM size
    const uint16_t _length = ((position & MEMORY_MASK_HUCK) + length >= MEM_SIZE) ? (MEM_SIZE - (position & MEMORY_MASK_HUCK)) : length;
    memcpy(&memory[(position & MEMORY_MASK_HUCK)],source,_length);

    const uint8_t page_start = uint8_t(position>>5);
    const uint8_t page_end   = uint8_t((position+length-1)>>5);

    for (uint8_t page = page_start; page <= page_end; ++page)// page 12 & 13 have write-counters, page 14&15 have hw-counters
    {
        if ((page == COUNTER_PAGE_START) || (page == COUNTER_PAGE_START + 1)) memcounter[page-COUNTER_PAGE_START]++;
    }

    return true;
}


//-------------- ONE WIRE 0x1D FUNCTIONS  ------------------------------------

// WRITE SCRATCHPAD
//-----------------
void cmd__0x0F_start_get_byte();
void cmd__0x0F_get_data_byte();
void cmd__0x0F_finish();
void cmd__0x0F(){ // prepare
  ow.read(reinterpret_cast<uint8_t *>(&reg_TA), 2, &cmd__0x0F_start_get_data); // read 2 bytes 16bit reg_TA;
} //    ||
  //    \/
void cmd__0x0F_start_get_data(){
  reg_TA &= REG_TA_MASK;
  reg_ES = uint8_t(reg_TA) & PAGE_MASK;
  ow.read(&scratchpad[reg_ES], 1, &cmd__0x0F_get_data_byte);
}//    ||
 //    \/
void cmd__0x0F_get_data_byte(){
  scratchpad[reg_ES]=data;
  if( (reg_ES & PAGE_MASK)==PAGE_MASK ) { // after read all data send crc16 and wait to reset
    crc=~_OW_crc16; // actual crc, must be separately stored because is continually changed during writes (and must be inverted because the crc algorithm requires it)
    ow.write(reinterpret_cast<uint8_t *>(&crc),2, &ow.reset);
  }
  else {
    reg_ES++;
    ow.read(&scratchpad[reg_ES], 1, &cmd__0x0F_get_data_byte); // read repeatly 1 byte until to end page
    // This implementation can'not detect if read whole byte, but I thing to is not matter, because master before copy stratchpad to memory must frist read scratchpad and check is data is corect
  }
}

// READ SCRATCHPAD
//-----------------
void cmd__0xAA_write_reg_ES();
void cmd__0xAA_write_data();
void cmd__0xAA(){
  ow.write(reinterpret_cast<uint8_t *>(&reg_TA), 2, &cmd__0xAA_write_reg_ES); // write 2 bytes 16bit reg_TA;
} //    ||
  //    \/
void cmd__0xAA_write_reg_ES(){
  ow.write((&reg_ES), 1, &cmd__0xAA_write_data); // write 1 bytes 8bit reg_ES;
} //    ||
  //    \/
void cmd__0xAA_write_data(){
  ow.write(&scratchpad[uint8_t(reg_TA) & PAGE_MASK], PAGE_SIZE-(reg_TA & PAGE_MASK), &ow.reset); // write data;
}

// COPY SCRATCHPAD TO RAM
//-----------------------
void cmd__0x5A_check_reg_TA0();
void cmd__0x5A_check_reg_TA1();
void cmd__0x5A_check_reg_ES();
void cmd__0x5A_finish();
void cmd__0x5A(){
  ow.read(&data, 1, &cmd__0x5A_check_reg_TA0);
} //    ||
  //    \/
void cmd__0x5A_check_reg_TA0(){
  if (data != reinterpret_cast<uint8_t *>(&reg_TA)[0]) ow.reset();
  ow.read(&data, 1, &cmd__0x5A_check_reg_TA1);
} //    ||
  //    \/
void cmd__0x5A_check_reg_TA1(){
  if (data != reinterpret_cast<uint8_t *>(&reg_TA)[1]) ow.reset();
  ow.read(&data, 1, &cmd__0x5A_check_reg_ES);
} //    ||
  //    \/
void cmd__0x5A_check_reg_ES(){
  if (data != reg_ES) ow.reset();
  // ignore if was error by not whole readed byte, because this implementation not able this detect (ignore REG_ES_PF_MASK)
  reg_ES |= REG_ES_AA_MASK; // compare was successful
  // we have ~30µs to write the date
  const uint8_t start_data     = uint8_t(reg_TA) & PAGE_MASK;
  const uint8_t length_data    = (reg_ES & PAGE_MASK) + uint8_t(1) - start_data;
  writeMemory(&scratchpad[start_data], length_data, reg_TA);
  cmd__0x5A_finish();
} //    ||
  //    \/  
void cmd__0x5A_finish(){
  data=ALTERNATING_10;
  ow.write(&data, 1, &cmd__0x5A_finish); // repeatedly write 0xAA until master reset
}


//  READ MEMORY
//-------------
void cmd__0xF0_write_frist();
void cmd__0xF0_write_next();
void cmd__0xF0(){
  ow.read(reinterpret_cast<uint8_t *>(&reg_TA), 2, &cmd__0xF0_write_frist); // read 2 bytes 16bit reg_TA;
} //    ||
  //    \/
void cmd__0xF0_write_frist(){
  reg_TA &= REG_TA_MASK;
  ow.write(&memory[reg_TA & MEMORY_MASK_HUCK], 1, &cmd__0xF0_write_next); // repeatedly write 0xAA until master reset
} //    ||
  //    \/
void cmd__0xF0_write_next(){
  if (reg_TA==REG_TA_MASK) {
    data=0;
    ow.write(&data, 1, &cmd__0xF0_write_next); // repeatedly write 0 until master reset
  }
  else {
     reg_TA++;
     ow.write(&memory[reg_TA & MEMORY_MASK_HUCK], 1, &cmd__0xF0_write_next); // repeatedly until end memery
  }
}

//  READ MEMORY + COINTER
//-----------------------
void cmd__0xA5_write_data();
void cmd__0xA5_write_counter();
void cmd__0xA5_zero_bits();
void cmd__0xA5_next_page();
void cmd__0xA5(){
  crc=_OW_crc16;
  ow.read(reinterpret_cast<uint8_t *>(&reg_TA), 2, &cmd__0xA5_write_data); // read 2 bytes 16bit reg_TA;
} //    ||
  //    \/
void cmd__0xA5_write_data(){
  reg_TA &= REG_TA_MASK;
  ow.write(&memory[reg_TA & MEMORY_MASK_HUCK], 1+ PAGE_MASK - (reg_TA & PAGE_MASK), &cmd__0xA5_write_counter); // write from reg_TA to end of page
} //    ||
  //    \/
void cmd__0xA5_write_counter(){
  uint8_t page  = uint8_t(reg_TA >> 5);
  if (page>=COUNTER_PAGE_START) { // page 12-15 have own counter
    ow.write(reinterpret_cast<uint8_t *>(&memcounter[page-COUNTER_PAGE_START]), 4, &cmd__0xA5_zero_bits); // write counter value associalized with page
  }
  else { // other pages 0-11 do not hve counters fill 32 bits by one
    memcounter[COUNTER_COUNT]=DUMMY_32b_ONES;
    ow.write(reinterpret_cast<uint8_t *>(&memcounter[COUNTER_COUNT]), 4, &cmd__0xA5_zero_bits); // write counter value associalized with page
  }
} //    ||
  //    \/
void cmd__0xA5_zero_bits(){
  memcounter[COUNTER_COUNT]=DUMMY_32b_ZERO;
  ow.write(reinterpret_cast<uint8_t *>(&memcounter[COUNTER_COUNT]), 4, &cmd__0xA5_crc); // write 32x zero
} //    ||
  //    \/
void cmd__0xA5_crc(){
  crc=~_OW_crc16; // I do not known way, bat crc value must be negated
  ow.write(reinterpret_cast<uint8_t *>(&crc), 2, &cmd__0xA5_next_page); // write crc
} //    ||
  //    \/
void cmd__0xA5_next_page(){
  _OW_crc16=0; // reset crc
  if ( (reg_TA | PAGE_MASK)== REG_TA_MASK) { // end last page
    ow.reset(); 
    return;
  }
  reg_TA = (reg_TA | PAGE_MASK) +1; // first byte next page
  cmd__0xA5_write_data(); // write data next page
}
  

// MAIN 0x1D FUNCTION
//--------------------
void ow_main_0x1D(uint8_t cmd)
{
  switch(cmd){
    case 0x0F:
      break;
      cmd__0x0F(); // WRITE SCRATCHPAD
      //digitalWrite(13, HIGH);
      break;
    case 0xAA:
      break;
      cmd__0xAA(); // READ SCRATCHPAD
      break;
    case 0x5A:
      break;
      cmd__0x5A(); // COPY SCRATCHPAD to RAM
      break;
    case 0xF0:
      break;
      cmd__0xF0(); // READ MEMORY
      break;
    case 0xA5:
      cmd__0xA5(); // READ MEMORY + COINTER
      break;
  }
}

// SAVE VALUES TO EEPROM
//----------------------
void save_values(){
  // copy memory to EEPROM
  cmpEE(&memory[0], EE_START_POINT, MEM_SIZE); 
  // copy counters to EEPROM
  cmpEE((uint8_t*) &memcounter[0], EE_START_POINT+MEM_SIZE, sizeof(memcounter[0])*COUNTER_COUNT); // copy conters to EEPROM scratchpad[2:4]
}

// INIT 
//-----
void ini() {
  // set default values
  memset(&memory[0], 0x00, MEM_SIZE);
  memset(&scratchpad[0], 0x00, PAGE_SIZE);
  memset(&memcounter[0], 0x00, sizeof(memcounter[0])*(COUNTER_COUNT+1));
  // load or save default values
  if (EEPROM.read(EE_FIRST_RUN) != 0xAA) { // first run -> save default values into eeprom
    save_values();
    EEPROM.write(EE_FIRST_RUN,0xAA);// write first run falg to EEPROM
  }
  else { // load values form EEPROM
    EEcmp(&scratchpad[2], EE_START_POINT,MEM_SIZE);  // load memory from eeprom
    EEcmp((uint8_t*) &memcounter[0], EE_START_POINT+MEM_SIZE, sizeof(memcounter[0])*COUNTER_COUNT); // load counters from eeprom
  }
  // ini OW
  ow.begin(&ow_main_0x1D, rom__);
  _OW_crc_mode=CRC_16; // prepare default crc mode (will be automaticaly calculate after ROM commands)
}

//-------------- TO SERVE POWEROFF (thank analog comparator interrupt) ----
AC_INT {
  memcounter[0]++; // first counter I use ask powerON counter
  save_values();
}


//-------------- ARDUINO SETUP ------------------------------------
void setup() {
  //Serial.begin(9600); // open the serial port at 9600 bps:
  //Serial.println("-START-");

  // setup One Wire
  ini(); // intialization of one wire interface for run bacground throught interrupt

  //setup analog comare for detect poweroff 
  CONF_AC // (defined in suportedMCU.h)

  // set pins of counters A,B
  pinMode(COUNTER_A, INPUT_PULLUP);
  pinMode(COUNTER_B, INPUT_PULLUP);
}

uint16_t  adresa_last=0xAAAA;
uint16_t  crc_last=0x1;

//-------------- ARDUINO MAIN LOOP ------------------------------------
void loop() {
   bool p;

   // COUNTER A
   p=digitalRead(COUNTER_A);
   if (p!=last_counterA){
    if (p==LOW) {
      memcounter[2]++;
     }
    last_counterA=p;
   }
   // COUNTER B
   p=digitalRead(COUNTER_B);
   if (p!=last_counterB){
    if (p==LOW) {
      memcounter[3]++;
    }
    last_counterB=p;
   }
}
