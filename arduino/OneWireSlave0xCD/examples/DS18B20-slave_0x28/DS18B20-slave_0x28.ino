/*
   Simulation of DS18B20 (1-Wire Temperature sensor)
   -------------------------------------------------

   Copyright (C) 2020 Ondrej Lycka info (at) seahu.cz

   The skeleton requres an incllude file with the device-specific dependent command handling.
   
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.

   Simulation of DS18B20 (1-Wire Temperature sensor)
   --------------------------------------------------
   
   Example is for AVR_ATMEGA328P can be also used on arduino uno, nano and leonardo, micro or AVR_ATtiny85 (but ATtiny85 do not have internal temperature sensor)
   (default One Wire pin for other platform refer to suportedMCU.h).
   Hardware platform and some options must be set into header (platform.h) file.
   Device ID is generated by base on compile date and time
                                                   
                                         ATMEL ATMEGA328P
                                        +-------\/-------+
                          (RESET)      -|1  PC6    PC5 28|- A5   (SCL)   
                          (RXD)     D0 -|2  PD0    PC4 27|- A4   (SDA)   
                          (TXD)     D1 -|3  PD1    PC3 26|- A3      
                          (INT0)    D2 -|4  PD2    PC2 25|- A2
   !prefered for OW! (OC2B,INT1)   #D3 -|5  PD3    PC1 24|- A1
                                    D4 -|6  PD4    PC0 23|- A0
                                       -|7  VCC    GND 22|-  
                                       -|8  GND   AREF 21|-  
                                       -|9  PB6   AVCC 20|-  
                                       -|10 PB7    PB5 19|- D13  (SCK)
                       (OC0B,T1)   #D5 -|11 PD5    PB4 18|- D12  (MISO)
                          (OC0A)   #D6 -|12 PD6    PB3 17|- #D11 (MOSI,OC2A)
                                    D7 -|13 PD7    PB2 16|- #D10 (OC1B)
                                    D8 -|14 PB0    PB1 15|- #D9  (OC1A)
                                        +----------------+  
*/


#include "platform.h"
#include <OneWireSlave.h>
#include <avr/pgmspace.h>
#include <EEPROM.h>
#include <string.h>
#include "eeprom_lib.h"
#include "comptime.h"

#define FAM 0x28 // family ROM code
#define EE_FIRST_RUN 0 // EEPROM address for check frist run (frist run write default values into EEPROM and save 0xAA on this address)
#define EE_START_POINT 20 // define start point to load and save data to EEPROM

// global variables
uint8_t scratchpad[9];
bool new_measure_flag; // flag from interrupt service OneWire bus to main loop from do new measure

// GENERATION OF UNIQUE ROM CODE
uint8_t rom__[8] = { FAM, SERIAL_NUMBER, 0x00 }; // SERIAL_NUMBER will be generated by timestamp during compile proces
//   will be calculated in begin:-------^^^^


OneWireSlave ow;  // global variable to class OneWireSlave

//-------------- MEASURE FUNCTION --------------------------------------------
/*
 * This function store float temperature value into scratchpad (DS18B20 binary format)
 * and check alarm.
 * You can run this function repeatedly any time.
 * This function take care of collision during write into scratchpad and simultaneous read from One Wire bus.
 */
void setTemperature(const float value_degC) {
    float value = value_degC; // float value of temperature
    int16_t value_raw; // raw value in form to store in scratchpat
    int8_t value_com;  // value for comapare alarm boundary
    bool alarm=false; // prepare for test alarm (no direct use of the _OW alarm, as this could theoretically create a small collision window between triggering this function and operating the OneWire bus by interrupting)
    
    if (value > 125) value = 125;
    if (value < -55) value = -55;
    value_raw= (int16_t)(value*16);
    while (_OW_lock==true) {}; // wait to unlock scratchpad
    scratchpad[0] = reinterpret_cast<uint8_t *>(&value_raw)[0];
    scratchpad[1] = reinterpret_cast<uint8_t *>(&value_raw)[1];
    value_com = (int8_t)(value_raw/16); // convert to whole degrees
    if ( value_com<(int8_t)(scratchpad[3]) ) _OW_alarm=true; //nim alarm
    if ( value_com>(int8_t)(scratchpad[2]) ) _OW_alarm=true; // max alarm
    if (alarm==true) _OW_alarm=true;
    else _OW_alarm=false;
    new_measure_flag==false; // reset flag for new measure
}

//-------------- ONE WIRE 0x28 FUNCTIONS  ------------------------------------

// WRITE SCRATCHPAD
void cmd__0x4E(){
  ow.read(&scratchpad[2], 3, &ow.reset); // read 3 bytes for write 3 byte of data to scratchpad[2:4]
} 

// READ SCRATCHPAD
void cmd__0xBE__finish();
void cmd__0xBE(){
  _OW_crc_mode=CRC_8;
  _OW_crc8=0;
  _OW_crc8c=0x00;
  _OW_lock=true;
  ow.write(&scratchpad[0],8, &cmd__0xBE__finish);
} //    ||
  //    \/
void cmd__0xBE__finish(){
  _OW_crc_mode=CRC_NO;
  scratchpad[8]=_OW_crc8;
  _OW_lock=false;
  ow.write(&scratchpad[8],1, &ow.reset);
}

// COPY SCRATCHPAD to EEPROM
void cmd__0x48(){
  scratchpad[4]|=0x1F;
  scratchpad[4]&=0xEF;
  cmpEE(&scratchpad[2], EE_START_POINT, 3); // copy to EEPROM scratchpad[2:4], ds18s20 only first 2 bytes (TH, TL)
  ow.reset();
}

// RECALL E2 (3 byte EEPROM to Scratchpad[2:4])
void cmd__0xB8(){
  EEcmp(&scratchpad[2], EE_START_POINT,3);
  ow.reset();
}

// READ POWER SUPPLY
void cmd__0xB4(){
  ow.write(&scratchpad[5],1, &ow.reset); // I always use external power therefore may be send one bit=1, but I send all byte 8x1 - (1: say i am external powered, 0: uses parasite power)
}

// CONVERT T --> start a new measurement conversion
void cmd__0x44(){
  // we have 94 ... 750ms time here (9-12bit conversion)
  new_measure_flag=true;
  ow.reset();
}

// MAIN 0x28 FUNCTION
void ow_main_0x28(uint8_t cmd)
{
  switch(cmd){
    case 0x4E:
      cmd__0x4E(); // WRITE SCRATCHPAD
      break;
    case 0xBE:
      cmd__0xBE(); // READ SCRATCHPAD
      break;
    case 0x48:
      cmd__0x48(); // COPY SCRATCHPAD to EEPROM
      break;
    case 0xB8:
      cmd__0xB8(); // RECALL E2 (3 byte EEPROM to Scratchpad[2:4])
      break;
    case 0xB4:
      cmd__0xB4(); // READ POWER SUPPLY
      break;
    case 0x44:
      cmd__0x44(); // CONVERT T --> start a new measurement conversion
      break;
  }
}

void ini() {
  // default scratchpad values
  scratchpad[0] = 0x0A; // TLSB --> 10 degC as std 
  scratchpad[1] = 0x00; // TMSB 
  scratchpad[2] = 0x4B; // THRE --> Trigger register TH 
  scratchpad[3] = 0x46; // TLRE --> TLow
  scratchpad[4] = 0x7F; // Conf // = 0 R1 R0 1 1 1 1 1 --> R0=0,R1=0 9bit; R0=0,R1=1 10bit; R0=1,R1=0 11bit; R0=1,R1=1 12bit temperature resolution
  scratchpad[5] = 0xFF; // RESERVED (FFh)
  scratchpad[6] = 0x00; // Reset
  scratchpad[7] = 0x10; // RESERVED (10h)
  scratchpad[8] = 0x00; // CRC from scratchpad[0-7]
  // load or save default values
  if (EEPROM.read(EE_FIRST_RUN) != 0xAA) { // first run -> save default values into eeprom
    cmpEE(&scratchpad[2], EE_START_POINT, 3); // copy to EEPROM scratchpad[2:4]
    EEPROM.write(EE_FIRST_RUN,0xAA);
  }
  EEcmp(&scratchpad[2], EE_START_POINT,3);  // load values from eeprom
  // ini OW
  ow.begin(&ow_main_0x28, rom__); 
}

// measure temperature by internal temperature sensor in AVR ATmega328P MCU (arduino nano)
float GetTemp(void)
{
  unsigned int wADC;
  float t=0; // default value for other MCU then AVR ATmega328P

  #ifdef __AVR_ATmega328P__
    // The internal temperature has to be used
    // with the internal reference of 1.1V.
    // Channel 8 can not be selected with
    // the analogRead function yet.
  
    // Set the internal reference and mux.
    ADMUX = (_BV(REFS1) | _BV(REFS0) | _BV(MUX3));
    ADCSRA |= _BV(ADEN);  // enable the ADC
  
    delay(20);            // wait for voltages to become stable.
  
    ADCSRA |= _BV(ADSC);  // Start the ADC
  
    // Detect end-of-conversion
    while (bit_is_set(ADCSRA,ADSC));
  
    // Reading register "ADCW" takes care of how to read ADCL and ADCH.
    wADC = ADCW;
  
    // The offset of 324.31 could be wrong. It is just an indication.
    t = (wADC - 324.31 ) / 1.22;
  #endif
  
  // The returned temperature is in degrees Celcius.
  return (t);
}

//-------------- ARDUINO SETUP ------------------------------------
void setup() {
  // setup One Wire
  ini(); // intialization of one wire interface for run bacground throught interrupt
}

//-------------- ARDUINO MAIN LOOP ------------------------------------
void loop() {
    if (new_measure_flag==true){ // new measure
      setTemperature( GetTemp() );
    }
   // .
   // ..
   // do what you want (but do not disable interrupt, if do known what you do)
   // ..
   // .   
   delay(10);
}