/*
   OneWireSlave0xDD - A skeleton 1-Wire multisensor emulator for AVR Microcontroller

   Copyright (C) 2020 Ondrej Lycka info (at) seahu.cz

   The skeleton requres an incllude file with the device-specific dependent command handling.
   
   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.

   Simulation of DS2413 (1-Wire Dual Channel Addressable Switch)
   --------------------------------------------------------------

   Example is for AVR_ATtiny can be also used on arduino leonardo or micro and nano (default One Wire pin for other platform refer to suportedMCU.h).
   Hardware platform and some options must be set into header (platform.h) file.

                                                   
                                    AVR_ATtiny85   
                                   +------\/-----+ 
                    (RESET) N/U 1 -|1 PB5   VCC 8|- 8 VCC
                         A3  D3 2 -|2 PB3   PB2 7|- 7 D2 A1 (SLC,INT0) ----> 1-Wire 
                  (OC1B) A2 #D4 3 -|3 PB4   PB1 6|- 6 #D1   (MISO,OC0B,AIN1,OC1A) ---> PIN_B
                         GND D5 4 -|4 GND   PB0 5|- 5 #D0   (MOSI,OC0A,AIN0,SDA,AREF) ---> PIN_A
                                   +-------------+ 
   
*/


#include "platform.h"
//#include <OneWireSlave.h>
#include <avr/pgmspace.h>
#include <EEPROM.h>
#include <string.h>
#include "eeprom_lib.h"
#include "comptime.h"

  
#define FAM 0x3a // family ROM code
//#define PIN_A 0 // for AVR_ATtiny85
//#define PIN_B 1 // for AVR_ATtiny85
#define PIN_A 4 // for arduino nano test
#define PIN_B 5 // for arduino nano test

// global variables
uint8_t Status_byte_;
uint8_t buf_0x3A_[2]; // buffer for OneWire communication

// GENERATION OF UNIQUE ROM CODE
uint8_t rom__[8] = { FAM, SERIAL_NUMBER, 0x00 }; // SERIAL_NUMBER will be generated by timestamp during compile proces
//   will be calculated in begin:-------^^^^s


OneWireSlave ow;  // global variable to class OneWireSlave

//-------------- ONE WIRE 0x3A FUNCTIONS  ------------------------------------

//0xF5 - PIO ACCESS READ
void cmd__0xF5(){
  // complete status byte
  if (digitalRead(PIN_A)==HIGH ) { Status_byte_ |=  0x01; Status_byte_ &= ~0x10;}
  else                           { Status_byte_ &= ~0x01; Status_byte_ |=  0x10;}
  if (digitalRead(PIN_B)==HIGH ) { Status_byte_ |=  0x04; Status_byte_ &= ~0x40;}
  else                           { Status_byte_ &= ~0x04; Status_byte_ |=  0x40;}
  //Status_byte_=0xF0;
   //Status_byte_ = data | (~Status_byte_ << 4);
  // write status byte by OneWire
  ow.write(&Status_byte_, 1, &cmd__0xF5); // repead until master send reset
}

//0x5A - PIO ACCESS WRITE
void cmd__0x5A__check();
void cmd__0x5A__new_status();
void cmd__0x5A(){
  ow.read(buf_0x3A_, 2, &cmd__0x5A__check); // read 2 bytes
} //    ||
  //    \/
void cmd__0x5A__check(){
  if (buf_0x3A_[0]!=(uint8_t)~buf_0x3A_[1]) {
    ow.reset(); // if data is not OK wait to reset signal
    return;
  }
  // SET PIN_A
  if (buf_0x3A_[0] & 0x01) { // PIN_A 1=input
    pinMode(PIN_A, INPUT);
    { Status_byte_ |= 0x02; Status_byte_ &= ~0x20; }
  }
  else {                     // PIN_A 0=output winth 0 (prepared in setup)
    pinMode(PIN_A, OUTPUT);
    digitalWrite(PIN_A, LOW);
    { Status_byte_ &= ~0x02; Status_byte_ |= 0x20; }
  }
  // SET PIN_B
  if (buf_0x3A_[0] & 0x02) { // PIN_B 1=input
    pinMode(PIN_B, INPUT);
    { Status_byte_ |= 0x08; Status_byte_ &= ~0x80; }
  }
  else {                     // PIN_B 0=output winth 0 (prepared in setup)
    pinMode(PIN_B, OUTPUT);
    digitalWrite(PIN_B, LOW);
    { Status_byte_ &= ~0x08; Status_byte_ |= 0x80; }
  }
  // send confirmation byte 0xAA
  buf_0x3A_[1]=0xAA;
  ow.write(buf_0x3A_[1],1, &cmd__0x5A__new_status);
} //    ||
  //    \/
void cmd__0x5A__new_status(){
  // complete status byte
  if (digitalRead(PIN_A)==HIGH ) { Status_byte_ |=  0x01; Status_byte_ &= ~0x10;}
  else                           { Status_byte_ &= ~0x01; Status_byte_ |=  0x10;}
  if (digitalRead(PIN_B)==HIGH ) { Status_byte_ |=  0x04; Status_byte_ &= ~0x40;}
  else                           { Status_byte_ &= ~0x04; Status_byte_ |=  0x40;}
  ow.write(&Status_byte_, 1, &cmd__0x5A); // repead until master send reset
}

// MAIN 0x3A FUNCTION
void ow_main_0x3A(uint8_t cmd)
{
  switch(cmd){
    case 0xF5:
      cmd__0xF5(); // PIO ACCESS READ
      break;
    case 0x5A:
      cmd__0x5A(); // PIO ACCESS WRITE
      break;
  }
}

void ini() {
  // ini OW
  ow.begin(&ow_main_0x3A, rom__); 
}

//-------------- ARDUINO SETUP ------------------------------------
void setup() {
  // setup pins
  pinMode(PIN_A, INPUT);
  pinMode(PIN_B, INPUT);
  digitalWrite(PIN_A, LOW); // prepare zero output
  digitalWrite(PIN_B, LOW); // prepare zero output
  Status_byte_=0xF0; // start value of Status_byte_
   
  // setup One Wire
  ini(); // intialization of one wire interface for run bacground throught interrupt
  Serial.begin(9600); // open the serial port at 9600 bps:
}

//-------------- ARDUINO MAIN LOOP ------------------------------------
void loop() {
   // .
   // ..
   // do what you want (but do not disable interrupt, if do known what you do)
   // ..
   // .   
}